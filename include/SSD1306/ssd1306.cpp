/**
 * @brief Driver for SSD1306 OLED display.
 *
 * @changelog
 * + J. Bergeron <janick@bergeron.com>
 *	- Refactored driver into a Strategy Pattern
 *	- Port to BoneLib
 * + Jul 2015 - T. Dack <troy@dack.com.au>
 *	- removed test code
 *	- changed namespace to SSD1306
 *	- integrated with BlackLib
 *
 * @author Limor Fried/Ladyada, Janick Bergeron, Troy Dack <troy@dack.com.au>
 * @license
 * \verbinclude "Adafruit BSD 3-Clause.txt"
 *
 * This is a library for our Monochrome OLEDs based on SSD1306 drivers
 *
 * Pick one up today in the adafruit shop!
 * ------> http://www.adafruit.com/category/63_98
 *
 * These displays use SPI to communicate, 4 or 5 pins are required to
 * interface
 *
 * Adafruit invests time and resources providing this open source code,
 * please support Adafruit and open-source hardware by purchasing
 * products from Adafruit!
 *
 * Written by Limor Fried/Ladyada  for Adafruit Industries.
 *
 * BSD license, check license.txt for more information
 * All text above, and the splash screen must be included in any redistribution
 *********************************************************************
**/

#include <BlackLib/BlackDef.h>
#include <SSD1306/ssd1306.h>
#include <unistd.h>
#include <cstdio>
#include <cstdlib>
#include <cstring>

namespace SSD1306 {

const unsigned int SSD1306_COMMAND_MODE = 0x00; /* C0 and DC bit are 0         */
const unsigned int SSD1306_DATA_MODE = 0x40; /* C0 bit is 0 and DC bit is 1 */

const unsigned int SSD1306_SETCONTRAST = 0x81;
const unsigned int SSD1306_DISPLAYALLON_RESUME = 0xA4;
const unsigned int SSD1306_DISPLAYALLON = 0xA5;
const unsigned int SSD1306_NORMALDISPLAY = 0xA6;
const unsigned int SSD1306_INVERTDISPLAY = 0xA7;
const unsigned int SSD1306_DISPLAYOFF = 0xAE;
const unsigned int SSD1306_DISPLAYON = 0xAF;

const unsigned int SSD1306_SETDISPLAYOFFSET = 0xD3;
const unsigned int SSD1306_SETCOMPINS = 0xDA;

const unsigned int SSD1306_SETVCOMDETECT = 0xDB;

const unsigned int SSD1306_SETDISPLAYCLOCKDIV = 0xD5;
const unsigned int SSD1306_SETPRECHARGE = 0xD9;

const unsigned int SSD1306_SETMULTIPLEX = 0xA8;

const unsigned int SSD1306_SETSTARTLINE = 0x40;
const unsigned int SSD1306_SETLOWCOLUMN = 0x00;
const unsigned int SSD1306_SETHIGHCOLUMN = 0x10;

const unsigned int SSD1306_MEMORYMODE = 0x20;

const unsigned int SSD1306_COMSCANINC = 0xC0;
const unsigned int SSD1306_COMSCANDEC = 0xC8;

const unsigned int SSD1306_SEGREMAP = 0xA0;

const unsigned int SSD1306_CHARGEPUMP = 0x8D;

// Scrolling const unsigned ints
const unsigned int SSD1306_ACTIVATE_SCROLL = 0x2F;
const unsigned int SSD1306_DEACTIVATE_SCROLL = 0x2E;
const unsigned int SSD1306_SET_VERTICAL_SCROLL_AREA = 0xA3;
const unsigned int SSD1306_RIGHT_HORIZONTAL_SCROLL = 0x26;
const unsigned int SSD1306_LEFT_HORIZONTAL_SCROLL = 0x27;
const unsigned int SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL = 0x29;
const unsigned int SSD1306_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL = 0x2A;

#define _BV(x) (1<<(x))

// the memory buffer for the LCD, in horizontal addressing order
static uint8_t buffer[SSD1306::WIDTH * SSD1306::HEIGHT / 8] = { 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80,
		0x00, 0x00, 0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80,
		0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
		0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8, 0xF8, 0xF8,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
		0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80, 0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF,
		0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7,
		0x01, 0x01, 0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7,
		0x01, 0x01, 0x01, 0x01, 0x83, 0xFF, 0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7,
		0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
		0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00,
		0x7F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF,
		0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F,
		0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7,
		0xC7, 0x8F, 0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8,
		0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03,
		0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03,
		0x01, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03,
		0x01, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03,
		0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00,
		0x00, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0,
		0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F, 0x87, 0xC7,
		0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C,
		0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F,
		0x07, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF,
		0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0, 0x00, 0x00,
		0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE,
		0x00, 0x00, 0x00, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8,
		0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E, 0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF,
		0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFE, 0xFC,
		0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6, 0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF,
		0xFF, 0x06, 0x06, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x06, 0x00, 0x00,
		0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8, 0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E,
		0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76, 0xE6, 0xCE, 0xCC, 0x80, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F,
		0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x0F,
		0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07,
		0x0E, 0x0C, 0x18, 0x18, 0x0C, 0x06, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01,
		0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C,
		0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x0F,
		0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00,
		0x00, 0x07, 0x07, 0x0C, 0x0C, 0x18, 0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04,
		0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00 };

// reduces how much is refreshed, which speeds it up!
// originally derived from Steve Evans/JCW's mod but cleaned up and
// optimized
#define enablePartialUpdate
#ifdef enablePartialUpdate
static uint8_t xUpdateMin, xUpdateMax, yUpdateMin, yUpdateMax;
#endif

static void updateBoundingBox(uint8_t xmin, uint8_t ymin, uint8_t xmax,
		uint8_t ymax) {
#ifdef enablePartialUpdate
	if (xmin < xUpdateMin)
		xUpdateMin = xmin;
	if (xmax > xUpdateMax)
		xUpdateMax = xmax;
	if (ymin < yUpdateMin)
		yUpdateMin = ymin;
	if (ymax > yUpdateMax)
		yUpdateMax = ymax;
#endif
}

SSD1306::SSD1306(BlackLib::BlackSPI* _spi, BlackLib::BlackGPIO* cs,
		BlackLib::BlackGPIO* rst, unsigned char height) :
				m_spi(_spi), m_cs(cs), m_rst(rst), m_height(height) {
	if (m_spi == NULL) {
		fprintf(stderr, "ERROR: No SPI bus initialised for SSD1306.\n");
		exit(1);
	}
	m_spi->open(BlackLib::ReadWrite | BlackLib::NonBlock);
	if (!m_spi->isOpen()) {
		fprintf(stderr, "ERROR: SPI bus initialisation failed for SSD1306.\n");
		exit(1);
	}

	if (height != 32 && height != 64) {
		fprintf(stderr, "ERROR: Height of SSD1306 OLED must be 32 or 64\n");
		exit(1);
	}
	if (m_rst == NULL) {
		fprintf(stderr, "ERROR: No GPIO pin specified for SSD1306::rst.\n");
		exit(1);
	}
	if (m_cs == NULL) {
		fprintf(stderr, "ERROR: No GPIO pin specified for SSD1306::dc.\n");
		exit(1);
	}
	m_sclk = m_dc = m_din = NULL;
	m_i2c = NULL;
}

SSD1306::SSD1306(BlackLib::spiName spi, BlackLib::BlackGPIO* cs,
		BlackLib::BlackGPIO* rst, unsigned char height) :
				m_cs(cs), m_rst(rst), m_height(height) {
	m_spi = new BlackLib::BlackSPI(spi);
	m_spi->open(BlackLib::ReadWrite | BlackLib::NonBlock);
	if (!m_spi->isOpen()) {
		fprintf(stderr, "ERROR: SPI bus initialisation failed for SSD1306.\n");
		exit(1);
	}
	if (height != 32 && height != 64) {
		fprintf(stderr, "ERROR: Height of SSD1306 OLED must be 32 or 64\n");
		exit(1);
	}
	if (m_rst == NULL) {
		fprintf(stderr, "ERROR: No GPIO pin specified for SSD1306::rst.\n");
		exit(1);
	}
	if (m_cs == NULL) {
		fprintf(stderr, "ERROR: No GPIO pin specified for SSD1306::dc.\n");
		exit(1);
	}
	m_sclk = m_dc = m_din = NULL;
	m_i2c = NULL;
}

SSD1306::SSD1306(BlackLib::BlackI2C* i2c, BlackLib::BlackGPIO* rst,
		unsigned char height) :
				m_i2c(i2c), m_rst(rst), m_height(height) {
	if (m_i2c == NULL) {
		fprintf(stderr, "ERROR: No I2C bus initialised for SSD1306.\n");
		exit(1);
	}
	m_i2c->open(BlackLib::ReadWrite | BlackLib::NonBlock);
	if (!m_i2c->isOpen()) {
		fprintf(stderr, "ERROR: I2C bus initialisation failed for SSD1306.\n");
		exit(1);
	}
	m_cs = m_sclk = m_dc = m_din = NULL;
	m_spi = NULL;
}

SSD1306::SSD1306(BlackLib::i2cName i2c, unsigned int slaveAddress, BlackLib::BlackGPIO* rst,
		unsigned char height) :
				m_rst(rst), m_height(height) {
	m_i2c = new BlackLib::BlackI2C(i2c, slaveAddress);
	m_i2c->open(BlackLib::ReadWrite | BlackLib::NonBlock);
	if (!m_i2c->isOpen()) {
		fprintf(stderr, "ERROR: I2C bus initialisation failed for SSD1306.\n");
		exit(1);
	}
	m_cs = m_sclk = m_dc = m_din = NULL;
	m_spi = NULL;
}

SSD1306::~SSD1306() {
	if (m_spi != NULL)
		m_spi->close();
	if (m_i2c != NULL)
		m_i2c->close();
}

/** Reset the display */
void SSD1306::reset(void) {
	if (m_i2c)
		return;
	if (m_cs != NULL)
		m_cs->setValue(BlackLib::high);
	if (m_rst == NULL)
		return;
	// toggle RST low to reset
	m_rst->setValue(BlackLib::low);
	usleep(500000);
	m_rst->setValue(BlackLib::high);
}

/** Clear the display */
void SSD1306::clear(void) {
	memset(buffer, 0x00, get_width() * m_height / 8);
	updateBoundingBox(0, 0, get_width() - 1, m_height - 1);
}

/** Refresh the display */
void SSD1306::refresh(void) {
	if (m_spi != NULL)
		m_cs->setValue(BlackLib::low);

#ifdef enablePartialUpdate

	unsigned int minRow = yUpdateMin / 8;
	unsigned int maxRow = yUpdateMax / 8;
	command(0x22);   // Set page start/end addresses
	command(minRow);
	command(maxRow);

	unsigned int minCol = xUpdateMin;
	unsigned int maxCol = xUpdateMax;
	command(0x21);                             // Set column start/end addresses
	command(minCol);
	command(maxCol);

	if (m_dc != NULL)
		m_dc->setValue(BlackLib::high);
	for (int row = minRow; row <= maxRow; row++) {
		for (int col = minCol; col <= maxCol; col++) {
			if (m_spi != NULL) {
				m_spi->transfer(buffer[(get_width() * row) + col]);
			} else {
				m_i2c->writeByte(SSD1306_DATA_MODE, buffer[(get_width() * row) + col]);
				if (m_i2c->fail()) {
					fprintf(stderr, "ERROR: I2C write failed for %x.\n", buffer[(get_width() * row) + col]);
				}
			}
		}
	}

	xUpdateMin = get_width() - 1;
	xUpdateMax = 0;
	yUpdateMin = get_height() - 1;
	yUpdateMax = 0;

#else

	command(0x21);                             // Set column start/end addresses
	command(0x00);// Start == 0
	command(0x7F);// End = 127
	command(0x22);// Set page start/end addresses
	command(0x00);// Start == 0
	command(get_height()/8-1);// End == #rows/8

	m_dc->setValue(BlackLib::high);
	for (int i = 0; i < get_height()*get_width()/8; i++) {
		if (m_spi) {
			m_spi->transfer(buffer[i]);
		} else {
			m_i2c->writeByte(SSD1306_DATA_MODE, buffer[i]);
			if (m_i2c->fail()) {
				fprintf(stderr, "ERROR: I2C write failed for %x.\n", buffer[i]);
			}
		}
	}

#endif

	if (m_spi != NULL)
		m_cs->setValue(BlackLib::high);
}

/** Return the width of the display, in pixels */
uint16_t SSD1306::get_width(void) {
	return WIDTH;
}

/** Return the height of the display, in pixels */
uint16_t SSD1306::get_height(void) {
	return m_height;
}

/** Set a color pixel */
void SSD1306::drawPixel(int16_t x, int16_t y, rgb_t color) {
	if ((x < 0) || (x >= get_width()) || (y < 0) || (y >= get_height()))
		return;

	uint8_t shade = (color.red + color.green + color.blue) / 3;

	// x is which column
	if (shade < 128)
		buffer[x + (y / 8) * get_width()] |= _BV(y % 8);
	else
		buffer[x + (y / 8) * get_width()] &= ~_BV(y % 8);

	updateBoundingBox(x, y, x, y);
}

/* Get the color of a pixel */
rgb_t SSD1306::getPixel(int16_t x, int16_t y) {
	if ((x < 0) || (x >= get_width()) || (y < 0) || (y >= get_height()))
		return RGB::black;

	if ((buffer[x + (y / 8) * get_width()] >> (7 - (y % 8))) & 0x1)
		return RGB::black;
	return RGB::white;
}

void SSD1306::begin() {
	reset();

	command(SSD1306_DISPLAYOFF);                    // 0xAE
	command(SSD1306_SETDISPLAYCLOCKDIV);            // 0xD5
	command(0x80);                                  // the suggested ratio 0x80
	command(SSD1306_SETMULTIPLEX);                  // 0xA8
	if (get_height() == 32) {
		command(0x1F);
	} else {
		command(0x3F);
	}
	command(SSD1306_SETDISPLAYOFFSET);              // 0xD3
	command(0x00);                                  // no offset
	command(SSD1306_SETSTARTLINE | 0x00);           // line #0
	command(SSD1306_CHARGEPUMP);                    // 0x8D
	command(0x14);
	command(SSD1306_MEMORYMODE);                    // 0x20
	command(0x00);                                  // Horizontal
	command(SSD1306_SEGREMAP | 0x01);               // SEG0 is column 127
	command(SSD1306_COMSCANDEC);                    // Scan from COM[N-1] to 0
	command(SSD1306_SETCOMPINS);                    // 0xDA
	if (get_height() == 32) {
		command(0x02);
	} else {
		command(0x12);
	}
	command(SSD1306_SETCONTRAST);                   // 0x81
	if (get_height() == 32) {
		command(0x8F);
	} else {
		command(0xCF);
	}
	command(SSD1306_SETPRECHARGE);                  // 0xd9
	command(0xF1);
	command(SSD1306_SETVCOMDETECT);                 // 0xDB
	command(0x40);
	command(SSD1306_DISPLAYALLON_RESUME);           // 0xA4
	command(SSD1306_NORMALDISPLAY);                 // 0xA6

	command(SSD1306_DISPLAYON);                 //--turn on oled panel

	// Refresh the screen (will display the AFI logo)
	updateBoundingBox(0, 0, get_width() - 1, m_height - 1);
	refresh();
}

void SSD1306::command(uint8_t c) {
	uint8_t cmd = c;
	if (m_spi != NULL) {
		m_dc->setValue(BlackLib::low);
		if (m_cs != NULL)
			m_cs->setValue(BlackLib::low);
		m_spi->transfer(cmd);
		if (m_cs != NULL)
			m_cs->setValue(BlackLib::high);
	} else {
		m_i2c->writeByte(SSD1306_COMMAND_MODE, c);
		if (m_i2c->fail()) {
			fprintf(stderr, "ERROR: I2C write failed for %x.\n", c);
		}
	}
}

} /* SSD1306 */

